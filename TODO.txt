TODO list - a centralized list of stuff I'd like to do
(in roughly priority order, *-marked means done)
===========================================================

 - Configuration support
    - Do we do it with a standard python-style "lots of kwargs", or something else?
    - I like the 'something else' option, since we can then do stuff like getting config from a Python file, a config file, or a user-provided dict() - which might just be dict(foo=bar) in the standard kwargs style.
    - Should actually provide options for configuring from, at least, a config file (ini-style/other?) and from a dict.  From a python module/file is also handy.
    - Config options:
        - debug
        - template directory
    - Future config options:
        - static directory - so we can serve statics
        - default charset/encoding?
        - lock to serialize all requests, if an app is non-thread-safe
        - More?
 * Move helper functions to sub-module
    * Move these to the application
        * Mixins are a good choice here, I think.
            * One for caching - CachingMixin
            * One for redirection - RedirectionMixin
            * etc.
            * Means that we can unit-test each mixin seperately
    * Add functions that check etag, last modified date, and then halt() with Not Modified if they match
        * Tests for these!
    * Helpers for other stuff?
        * expires(some time value)
        * cache_control(various params, e.g. public=True/False, max_age=60, must_revalidate=True/False)
    * Look in to if-match and if-none-match headers to see how we handle them
    * redirect_back helper that is a wrapper around redirect() and the referrer?
 * URL generation that properly handles different mountpoints
    * As part of this, it might be worth making a Route() class that encapsulates the concept of a method, conditions, the route itself, and a matcher.  This could be helpful, because said Route() object could also handle reversing a route - i.e. getting a URL for a given route, given some parameters.
    * Might be worth integrating this into the Matcher concept.  For example, we could have a matcher that has the concept of:
        * path (i.e. the input path)
        * match(test_path) should return True, args, kwargs if match, or False, None, None otherwise.  these args/kwargs are then passed to the underlying route function
        * finally, the matcher can have a reverse(args, kwargs) function that will use those parameters to return a given path
        * default matcher should be HobokenPathMatcher, which uses the standard splat (*)/param (:param) matching style.  move the logic out of the Hoboken class.
    * TODO: tests for this
 - Integrate with Shift
 - Integrate with itsdangerous to provide secure cookie support
 - Session support - should allow hooking into this, so we can use e.g. beaker, or something like dogpile, just a cookie, etc
 * Test URL params/args in before()/after()/condition functions
 * Tests for the various helper functions and underlying exceptions
 * Allow arbitrary parameters to be passed to HaltRoutingException
 * Implement redirect() in a sensible manner
 - Testing support
    - Use inspect() to verify function parameters, if we go with func(*args, **kwargs) for route functions
    - Helpful web test cases
        - Stuff like assert_has_header, assert_body_is, etc.
        - Other stuff?
 - More logging
 - Automation (e.g. bump version, test, deploy, etc. - as a Fabfile?)
 - Upload to PyPI
   - Fix author/author_email
   * MANIFEST.in
   * README.txt^H^H^H^H.md
 - sendfile() support of some kind (checkout wsgi.file_wrapper in PEP 333[3], also X-Sendfile)
 - Examples
   - Middleware examples (e.g. security, stuff like that?)
   - File upload example
   - Simple hello-world
   - Larger app (todo list like everyone else?)
 - Integration examples
   - Some sort of DB (SqlAlchemy?)


Longer-Term TODOs
===========================================================

 - File uploads are currently non-ideal
 - Look into switching to Werkzeug's request/response objects.
   - Upsides:
     - I like the immutability of the Request
     - Seems more generally-exensible
     - send_file support is handy
     - File uploading is generally better
   - Downsides / things that bother me:
     - No Python3 support, pretty much a dealbreaker
     - str(request) doesn't return the HTTP-ified version.  WebOb does this, which is really handy
 - Might be worth making my own request/response objects that wrap the underlying bits?
   - I.e. make a req/resp object that provides the "basic" information as properties, and delegates to the underlying implementation to actually do the parsing, and so on.  This would make the actual request/response objects relatively framework-independent.
   - Downside: will be slower due to the indirection, not convinced this is 100% the correct thing to do.

Planning
===========================================================
The current method for request handlers involve passing around Request and Response objects manually, like this:

@app.get("/path")
def request_handler(request, response):
    # Do stuff
    pass

There are some alternative options:

1. Do something like Flask, with an import from the module that refers to the current request.
    - This is probably not a good idea, since we can have multiple apps running in the same process, and this would collide.
   This would look like this:

from hoboken import request, response

@app.get("/path")
def request_handler():
    # Do stuff with request and response.
    pass

2. We could assume that each application only processes one request at a time, and make the request and response object a property of the current application.
    - Combine this with threadlocals so we can have multiple threads processing on the same applications.
   This would look like this:

@app.get("/path")
def request_handler():
    # Do stuff with app.request and app.response.
    pass

   I like this best.  Another reason it's nice: the various halt() / redirect() / whatever functions don't need to take an explicit `req` or `resp` parameter, but instead can be methods on the application.  i.e. instead of writing:

@app.get("/")
def idx(req, resp):
    redirect(req, "/otherpath")

   You can instead write something more like this:

@app.get("/")
def idx():
    app.redirect("/otherpath")

   And the redirect() method will grab the request object from the application object, and use that to redirect to the new location.  Similarly for stuff that, e.g. checks the etag, or cache-control, or anything else that works on both request and response (because check_etag(request, response, etag) is so much more ugly than app.check_etag(etag).


Other Considerations
====================
We could allow the parameters to be passed to the functions themselves.  Splat parameters as *args, other params as **kwargs

@app.get("/*/:param/*")
def request_handler(first_splat, second_splat, param=None):
    pass

vs.

@app.get("/*/:param/*")
def request_handler():
    splats = app.request.urlargs
    param = app.request.urlvars['param']


